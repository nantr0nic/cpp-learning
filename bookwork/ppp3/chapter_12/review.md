# Review Questions
1. What is an application domain?
2. What are ideals for naming?
3. What can we name?
4. What services does a Shape offer?
5. How does an abstract class differ from a class that is not abstract?
6. How can you make a class abstract?
7. What is controlled by access control?
8. What good can it do to make a data member private?
9. What is a virtual function and how does it differ from a non-virtual function?
10. What is a base class?
11. What makes a class derived?
12. What do we mean by object layout?
13. What can you do to make a class easier to test?
14. What is an inheritance diagram?
15. What is the difference between a protected member and a private one?
16. What members of a class can be accessed from a class derived from it?
17. How does a pure virtual function differ from other virtual functions?
18. Why would you make a member function virtual?
19. Why would you not make a member function virtual?
20. Why would you make a virtual member function pure?
21. What does overriding mean?
22. Why should you always suppress copy operations for a class in a class hierarchy?
23. How does interface inheritance differ from implementation inheritance?
24. What is object-oriented programming
---
### My Answers
1. Broadly speaking, an application domain is the kind of program we're trying to make. Knowing what kind of program we're trying to make helps us to determine the design principles of the program's code base; those principles end up being the fundamental application concepts and facilities for programmers. If we're trying to make a medical database program, then our design principles might focus on searching through large datasets, adding/removing data from those sets, presenting the data in a reasonable and useful way, and performing all of those functions efficiently (in a performance sense). We would then focus on implementing the relevant concepts of this medical database (e.g. names, ID's, dates, locations, symptoms, etc.) and the facilities for performing the aforementioned functions (organizing the data by aforementioned concept, or sorting relevant data chronologically, alphabetically, etc -- or, creating functions to output organized data into charts, tables, or JSON files, etc.). We should also consider the limits of the domain in conjunction with the purpose of our application. Our goal should be for an application to fulfill a specific role (rather than "do it all") then design our class hierarchies to reflect the application's functions within the limits of our goal(s).
2. The ideal for naming should be self-documentation. If you name something then write a comment explaining the name, then there is perhaps a more clear name that might be better. For example, "sortByLastName" rather than "sortBLN" or "sort2". Or, for variables, "diameter" rather than "r2". Our naming conventions should reflect the logic of operations -- for example, Shape's "add" versus "attach". 
3. We can name classes/structs/enums, functions, variables, and constant expressions. 
4. Shape is an abstract class that offers services necessary for derived classes such as setting color, fill color, line styles, it keeps the 'points' of shapes, it provides the pure virtual functions for draw_specifics, etc. It also handles the interaction between our graphics library and the underlying Qt library that's working with our operating system to draw windows and the elements within.
5. An abstract class cannot be instantiated as its own object whereas a non-abstract class can. Abstract classes help structure common facilities for their derived classes and help organize the hierarchy of our library. 
6. You can make a class abstract by giving it at least one pure virtual function or by making its constructor a protected member.
7. Members of a class are controlled by access control -- whether they by member functions or data members. I think anything you can put into a class can be made public, private, or protected. You can put structs into the private part of a class and have functions in that struct as well.
8. Making a data member private is (usually) necessary to respect the principle of encapsulation. We want encapsulation as a design principle because it helps to document what data is internal to a class' purpose as opposed to what a user of that class should have access to. It also helps to prevent accidental modification of those data members by outside functions/code.
9. A virtual function is a function that can be overriden by a derived class. When a class contains a virtual function, the compiler generates a vtbl for that class which contains pointers to the relevant functions (which can be either functions from the base or further-derived classes); when a virtual function is called what happens at runtime is called 'dynamic dispatch' -- at runtime, the program uses an object's vtbl to call the relevant function directly. For example, if you have abstract class A, derived class B, and class C that is derived from B, A's vtbl will contain pointers to its own functions (using an empty slot for a pure virtual function), B's will have pointers to its own overriding functions and pointers to functions it inherits from A, and C can have pointers to its own, B's, and A's functions and so on. This type of design illustrates the concept of 'polymorphism'. 
   1.  An interesting example is when you have a case of 'indirection' where a base class is instantiated through a reference or pointer. In this situation there is a distinction between the static and dynamic type for that object -- where the static type is the type of the pointer or reference and the dynamic type is the type of the actual object (being pointed/referred to). Thus, if you have a non-virtual function in an abstract class A then you can call that non-virtual function if you instantiate and object of derived class B by pointer/reference of A -- the compiler will (at compile time, like for all non-virtual functions) determine the function code based on the static type: in this case, A. I mention this interesting "exception" because it at first caused me confusion. 
A non-virtual function is statically dispatched and determined at compile time based on the the call type.
10. A base class is a class used to derive 'lower' classes. A base class ought to be conceptually 'higher' than its derived classes -- for example base 'plant' should have derived class 'redwood' and not the other way around. Everything that is true of the base class ought to be true of (or possible with) its derived class. We can use pure virtual functions to provide facilities in base classes that are possible for every derived class but can be overriden by those classes to account for differences in implementation (for example, Shape can have pure virtual function move() but Rectangle and Circle -- both derived from Shape -- can override move() where rectangle uses the top-left point as a reference for movement and circle uses its center point as reference).
11. What makes a class derived is the notation in its declaration -- ```class Derived : **public Base** { // class block }; ```. Conceptually, what makes a class derived is if it is a logically distinct category wholly contained within the concept of its base class. All trees are plants (but not vice versa) and all evergreens are trees (but not vice versa) so if we wanted to create a class Evergreen within this hierarchy, we would make Evergreen a class derived from Tree which is derived from Plant. So Evergreen would inherit from Tree, but if we had a separate branch (no pun intended) with a Succulent class derived from Plant, then we could create virtual functions in Tree that Evergreen would inherit but wouldn't be inherited or accessed by Succulent types.
12. Object layout refers to how objects are laid out in memory. Members of a class define the layout of objects where data members are stored sequentially. If a class is derived, the data members it inherits are listed first then its own unique data members (if any) are added after those. Member functions are NOT stored "in objects" or along with the data members. Though it varies between compilers how exactly functions are 'stored' the function code is usually stored separately from data members. If a class has or inherits virtual functions, a vtbl is created for that class which contains pointers to the appropriate function (for example, the overriding function of class C, or inherited functions from B or A, etc.). These pointers are called vptr's. (Virtual function stuff is covered in answer #9.)
13. This chapter didn't cover class testing, however I'll answer using my intuition. You can make a class **easier** to test by writing self-documenting code and further explicating expected results in comments then write functions that call the various functions and get the data members of that class. With a class hierarchy what might make sense is to (perhaps) write a 'debug' class and make it the most-derived class so it inherits the functions above it and then you could just test that one class; where something might be a pure virtual function and/or overriden multiple times (like move() for Rectangle vs Shape) you would then write individual tests within those classes.
14. An inheritance diagram shows the relationship betwen base and derived classes in a class hierarchy. It becomes increasingly useful as the class hierarchy grows.
15. A private member is accessible by that class only, whereas a protected member is still inaccessible to the 'outside' but can be accessed by classes derived from the class where the protected member is declared/defined.
16. Public and protected.
17. A pure virtual function turns the class it is declared within to become an abstract class that then cannot be instantiated. The pure virtual function must be given a definition in a derived class or that class (and any classes further derived) cannot be instantiated as well. Meaning, if class A has a PVF, it must be defined in B or else B, C, D, etc. cannot be instantiated. Notation wise, a PVF is declared with ```virtual void pure_virtual_function() = 0;```.
18. You would make a member function virtual in a class if you want any derived classes to be able to override that function. Base class 'car' could have a virtual function to 'refuel' but a derived class 'electric' could override 'refuel' to represent charging the car instead of refueling with gasoline.
19. You would NOT make a member function virtual if you want derived classes to have the function (by inheritance) but NOT be able to override it. For example, if you have a base class that tests a cryptography key you might have derived classes that inherit that function for passwords or account details but you want them to all test cryptography keys identically.
20. You would make a virtual member function pure to designate a class as abstract where that class cannot be instantiated but conceptually any class derived from that base ought to have that function. For example, Shape has move() because every derived class (specific shapes) can all move but the Shape class itself is abstract and cannot be instantiated. There is no "shape" as such because it is a category that contains specific shapes, thus, a fortiori, "move" has no meaning for "shape" in itself but members of "shape" can all "move".
21. Overriding is when an inherited function has code that is executed instead of the code in the base function's definition. "Override" is an unnecessary but highly encouraged keyword to include on derived class functions that marks functions that override their virtual base counterpart.
22. You should always suppress copy operations for a class in a class hierarchy because it is very often the case that derived classes will have incompatible invariants -- in this case, the best option is often to write specific copy constructors restricted to a single class. Shape stops copying by declaring ```Shape (const Shape& = delete;``` to prohibit actions like assigning a Rectangle to a Circle (which have incompatible constructors because a Rectangle is represented by two Points whereas a Circle is represented by a Point and an int).
23. Interface inheritance is when a derived class inherits the interface provided by a base class, where that derived class can be passed to a function expecting the base class type. That is, if a function is expecting a Plant&, we can pass Oak, Redwood, Willow, and so on to that function. Implementation inheritance is when a derived class inherits the data and member functions of its base class, where photosynthesis() can be defined in Plant and the classes Redwood and Willow inherit that function. The ideal of inheritance is that the derived classes benefit from either one or both forms. One of the many benefits of inheritance is that we can add new derived classes to base classes and inherit the relevant functionality without having to modify the base class. Bjarne calls this the "holy grail of software design/development/maintenance" -- the ability to extend "a system without modifying it." He says a design that does not provide interface inheritance is "poor and error-prone."
24. What is OOP? Oh jeeze. I'll try to summarize it here... Object-oriented programming is programming where classes (that create objects in the program) are fundamental to the design and execution of a program. This is different than **functional** programming, where there are no classes and objects -- in this style of programming (for example, C) programs are an assemblage of either global or encapsulated functions that do the work (Bjarne didn't talk about functional programming in the text so I'm speculating here). One of the main benefits of OOP (besides the logical relationships between concepts that it allows) is interface inheritance, and, too, implementation inheritance. A few key mechanisms that OOP allows for in C++ are derivation, virtual functions, and private/protected members -- other common terms for these (respectively) are inheritance, run-time polymorphism (or dynamic dispatch), and encapsulation. 
    1.  For fun...I'll do some more speculation! It can be said that OOP can effectively reflect ontological relationships between concepts and objects: abstract classes can contain logical concepts that can then be instantiated into objects. So abstract class "Technology" can contain derived class "Digital Camera" that has private members like make, model, year, battery_type, etc. Reflecting this type of relationship between concept and object -- though possible, I'm sure -- seems significantly more difficult in functional programming than object-oriented programming.