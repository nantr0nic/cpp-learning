## Review Questions
1. What are the two parts of a class, as described in the chapter?
2. What is the difference between the interface and the implementation in a class?
3. What are the limitations and problems of the struct Date from §8.4.1?
4. Why is a constructor used for the Date type instead of an init_day() function?
5. What is an invariant? Give examples.
6. When should functions be put in the class definition, and when should they be defined outside the class? Why?
7. What is a default constructor and when do we need one?
8. What is a default member initializer?
9. When should operator overloading be used in a program? Give a list of operators that you might want to overload (each with a reason). Which ones can you define in C++?
10. Why should the public interface to a class be as small as possible?
11. What does adding const to a member function do?
12. Why are “helper functions” best placed outside the class definition?
13. How does an enum class differ from a “plain” enum?
---
### My answers:
1. The two parts of a class are its *interface* and its *implementation*. These are labeled as *public* and *private*, respectively. 
2. Wherever the class is used, the code outside of the class has access to the data and functions in the (public) interface; whereas, the data and functions in the implementation are only accessible within the class (i.e., the data can only be accessed by the same class member functions, the private member functions can only be called by member functions of the same class). Another distinction is that the interface defines **what** the class **does** and the implementation defines **how** it does that.
3. The limitation/problem with making Date a *struct* as opposed to a *class* is that in a struct the representation of Date is accessible to everybody. This is undesirable because it makes it easier for users (or other parts of the code) to produce bad results / invalid values. The user does not need all of the implementation details of Date. Being able to define what is and is not accessible to users in a class lessens the chance for mistakes to be made and it communicates the implementation and concept of the class more effectively. 
4. A constructor is preferable for a class because it defines the default state of any instantiated class object. Creating an empty object and using a separate member function to initialize values for that object is bad design.
5. An invariant is "a rule for what constituted a valid value." That is, an invariant is the rule that determines what valid values are for the instantiated objects of a class. Some examples might be... The invariant of a class modeling the results of a sensor reading temperature and humidity of a room is "A *Reading* must represent the temperature and relative humidity readings from a BME-280 sensor: the range of temperature that the sensor can read (-50 degrees C to 120 C) and the range of RH the sensor can read (5% to 100%)." /// The invariant of a class of enemies in a (simple) video game might be: "The class *Enemy* must represent a sprite (i.e. an animated image) at a given position on the screen (e.g. {X / Y}) that has the properties of health (i.e. the amount of damage it can sustain until it is deleted) and damage (i.e. the amount of damage it can cause the player)." /// The invariant of a class of Shape(s) might be: "The class *Shape* must represent any polygon with three or more sides that have non-zero lengths."
6. Functions that are small (no more than 2 lines!) or that are small and ought to be inline-ed for optimization should be placed within the class definition. The functions of any larger size should be placed outside of the class definition. Function that are defined within the class definition might be treated as inline by some compilers which could significantly increase compile times for large projects. Beyond this, keeping larger functions outside of the class definition makes the code clear and easier to read.
7. A constructor is a special member function of a class that defines how objects of that class are created and initialized. A default constructor is a constructor that can be called with no arguments: either it takes no parameters, or every parameter has a default value. If you do not define any constructors for your class, the compiler will automatically provide a default constructor for you. However, if you define any other constructor, and you still want a default constructor, you must define it yourself.
8. Default member initializers are when data members are initialized to a default value in their definition in the class definition body.
9. Operator overloading should be used in a program when you want assigns functions to operators that take class objects as operands. For example, "<<" does not (by default) accept vector objects (nor any user-defined type) so you will need to overload the << operator to accept and return vectors and so on. You can only define/overload already existing operators (you cannot write your own like '@='). Out of the already existing operators you must respect their conventional number of operands (unary operators must remain unary, you cannot make them binary, etc.). You cannot overload built-in type operators (e.g. `int operator+(int,int);` ). Besides the "<<" example, here are additional examples of when and how you might want to overload operators:
   1.  you might want to overload "<" to compare the number of items in two vectors, for example comparing the number of items in two inventories
   2.  you might want to overload "==" to verify that the day of the week that two dates fall on are the same 
   3.  you might want to overload "=" to copy Enemy objects in a video game where enemies might clone themselves
   4.  you might want to overload "++" to increase the volume or go to the next channel for a user-defined type modeling a TV remote
10. The public interface of a class should be as small as possible because keeping it small will encourage efficient code that is comprehensible. If a user needs to use the class, it will take less effort for them to understand and implement the class (hopefully!). A small public interface also lessens the amount of debugging required if a user is able to produce bad values with public functions.
11. It tells the user that the function will not modify the values passed to it, and it also enables const values to be passed to that function. 
12. Functions that **need** to access implementation data should be member-functions of that class. Following the ideal of minimizing a class interface (while keeping it *complete*), the number of these functions ought to be kept to whatever is necessary -- allowing for exceptions where the goal includes user comprehension and keeping the class' public interface comprehensible for fellow programmers. Functions that do not access the private implementation data of a class but help extend the use of that class ought to be kept *outside* of that class -- such functions are called 'helper functions', or sometimes 'convenience functions' or 'auxiliary functions'.
13. An enum (enumeration) is "a very simple user-defined type, specifying its set of values (its enumerators) as **symbolic constants**." A class enum differs from a plain enum in that class enums are "*scoped* enumerations", whereas plain enums are not scoped and the enumerations are "exported" to the scope the enumeration is called in. One benefit of a plain enum is that its enumerations allow implicit conversions to *int* type. The undesirable effect is that the plain enum enumerations can "'poullte' the scope in which their enumerator is defined." So if we define a plain enum with an enumerator "dec" that might conflict with "dec" for decimal. With a class enum the enumeration would be called with "Month::dec" and would NOT conflict but a helper function must be written to convert the "dec" to an int or vice versa.