# Review Questions
1. Why does code written by different people look different? Give examples.
2. What are simple questions we ask of data?
3. What are a few different ways of storing data?
4. What basic operations can we do to a collection of data items?
5. What are some ideals for the way we store our data?
6. What is an STL sequence?
7. What is an STL iterator? What operations does it support?
8. How do you move an iterator to the next element?
9. How do you move an iterator to the previous element?
10. What happens if you try to move an iterator past the end of a sequence?
11. What kinds of iterators can you move to the previous element?
12. Why is it useful to separate data from algorithms?
13. What is the STL?
14. What is a linked list? How does it fundamentally differ from a vector?
15. What is a link (in a linked list)?
16. What does insert() do? What does erase() do?
17. How do you know if a sequence is empty?
18. What operations does an iterator for a list provide?
19. How do you iterate over a container using the STL?
20. When would you use a string rather than a vector?
21. When would you use a list rather than a vector?
22. What is a container?
23. What should begin() and end() do for a container?
---
# My Answers
1. This is a hard question to answer but I'll give it a go: 
   1. There are the various syntax styles that different people use when programming in C++. Two popular styles are K&R and Allman (I prefer the latter) -- this results in the first obvious difference. In conjunction with this superficial difference there are also personal preferences and common application conventions. Some personally prefer camelCase to snake_case, some list constructor member initializers on the same line, some (like myself) prefer them on separate lines, some edit their code to not exceed 79 characters wide, some go as far as 110, etc. Certain conventions exist within application domains, like I've noticed game development C++ is usually in Allman style and uses m_name for class data members. Oh, and not to mention the infamous spaces vs tab :)
   2. There are "versions" of C++ where new features are introduced with each consecutive release (meaning C++98, C++11, C++20, the upcoming C++26, etc.). Type deduction using 'auto' has been extended a few times, for example C++20 introduced "abbreviated" function templates using auto. Move semantics were introduced in C++11. These features can make code look quite different -- some individuals and organizations choose to stick with a set of features and so may produce new code in 2025 but restrict their code to features up to C++17, for example. The variety of features available also engender various coding conventions that might be particular to a "style" of programming. 
   3. There are four "paradigms" of programming, we have covered three of them and their application in C++: procedural, functional, object-oriented, and generic programming. Sometimes the same problem can be solved in each of these paradigms but the solution will look very different between these paradigms.
   4. More pertinent to this chapter, there are a variety of implementations that can be used for solutions to the same problem even within a paradigm. Point in case: for a text editor, one can use ```std::vector```, ```std::list```, ```std::array```, ```std::string``` to implement the same feature (e.g. storing a line of text) or use all of these implementations in varying combinations for different features (e.g. a vector of strings for a page of lines, a list of character arrays for an editing buffer) -- or, ultimately, if one really wanted to (or was sticking with C programming) all of the same features could be implemented with only arrays and pointers. This wide variety of possible solutions to the same problems results -- inevitably -- in different looking code from different people.
   5. Lastly, there are differences in approach to things like memory management and exception handling. This might vary for a number of reasons: where the software is to be used and by whom impacts our approach; if an exception being thrown is it impacting a critical system (e.g. hospital equipment or public infrastructure); if we are writing code for a tiny embedded device we might prefer manual memory management over code that might perfectly exemplify RAII, etc.
2. This is a vague question. To answer vaguely, we ask simple questions like: what kind of data is it (what data types does it contain); how is (or should) this data be organized; is this data mutable or should is it just for "reading"; how should this data be stored (in relation to our code, not physically).
3. In this chapter we saw that we can store data in STL containers like ```std::array```, ```std::vector```, ```std::list```, but there are more containers available to us from the STL. These are ways to store data that we process in our programs. For consistent data storage there are also solutions that use JSON, YAML, and other related formats.
4. Some -- of the many -- basic operations are do to a collection of data items include: accessing data, sorting data by some metric, filtering data, finding points within data (search), extrapolating information from data (analysis, statistics), and manipulating data (finding sums, differences, etc.). The main C++ feature that is required for carrying out these operations efficiently is the iterator. We can use iterators to program generic functions that work with many (most?) of the STL containers; or, alternatively, we can make iterators for our own "home brewed" containers. 
5. Some of the ideals we covered in this chapter are: uniform access to data (independently of its type and storage), type-safe access to data, easy traversal of data, compact storage of data, and fast retrieval/addition/deletion of data. In addition to these ideals we want standard versions of the most common algorithms to work with our data storage.
6. An STL "sequence" -- also called a _range_ -- is a collection of data that consists of a beginning and end. Sequences are defined by half-open ranges: [begin:end)
7. An STL iterator is a pointer that traverses a container or sequence and it allows us to access or manipulate items in a sequence by moves from item to item. Iterators are pointers to elements in a container and STL algorithms that utilize iterators can be extended to user-defined types by creating ```T* begin()``` and ```T* end()``` member functions.
8. You move an iterator to the next element using the increment operator ```++```. If ```p``` is an iterator you advance it forward like so: ```++p```
9. You move an iterator to the previous element using the decrement operator ```--```. If ```q``` is an iterator you advance it backward like so: ```--q```
10. If you don't have a bound check in place, I believe the iterator would move onto uninitialized or other objects' memory addresses. If possible, a bound check would disallow an iterator to move past ```end()``` -- the location one past the last element. The iterator facilities in the STL are not allowed to point outside of a sequence, thus when that is required a non-iterator pointer must be used. An iterator moving past its bound results in undefined behavior and should never happen in correct code.
11. In addition to iterators a user defines for their own classes... you can move ```std::bidirectional_iterator``` to previous elements or use a "random access" iterator to move to previous elements or jump to any element in a sequence. Other iterators like ```std::forward_iterator```, ```std::input_iterator```, and ```std::output_iterator``` cannot mvoe backwards.
12. Separating data from algorithms separates realms of concern such that an algorithm doesn't "know" anything about the data and how it is stored, it simply fulfills its function using iterators. Likewise, data structures don't "know" anything about algorithms and can be focused on the logic of relations between their elements. By simply providing ```begin()``` and ```end()``` they can expose themselves to the utility of algorithms.
13. The STL is the **S**tandard **T**emplate **L**ibrary. Part of the ISO C++ standard library, the STL is a "framework for general, correct, and efficient algorithms operating on data structures" (p.818) and it consists of "about a dozen containers and about 125 algorithms connected by iterators" (p. 821). ```std::vector``` is an example of such a container, and ```std::find```, ```std::sort```, and ```std::move``` are a few of the (many) algorithms it provides. Alex Stepanov designed the STL, and the ideal of its design was the "simplicity, generality, and elegance of mathematics" (p. 818).
14. A linked list is a container where each element has either one pointer to the next element (singly-linked) or two pointers to the previous and successive elements (doubly-linked). It is fundamentally different from a vector in a few ways:
    1.  Vectors are contiguously stored whereas linked lists do not need to be contiguously stored
    2.  An element in a linked list consists of its object/value **and** one or two pointers -- thus linked lists take up considerably more memory. For example, a vector of ```char``` would take up 1 byte per char element, whereas for a double-linked list that same char would take up 1 byte for its value, and (on a 64-bit system) 8 bytes per pointer.
    3.  Insertion and deletion in a list is "simpler" (in terms of CPU instructions) in that inserting or removing an item consists of reassigning a few element's pointers appropriately, whereas in a vector inserting/deleting an element can be intensive: for example, adding an element at the 7th position in a container of 1000 elements requires moving 993 elements "over" one.
15. A link in a (doubly-linked) list is consists of three things: the value, a pointer to the next element, and a pointer to the previous element.
16. ```insert()``` inserts an element after the element pointed at in its argument and returns a pointer to the inserted element; ```erase()``` removes the element pointed at by the pointer in its argument.
17. You know a sequence is empty if the ```begin()``` iterator is equal to the ```end()``` iterator. I learned in this chapter that this is the "deeper reason" for having ```end()``` point one beyond the last element (rather than at the last element) is to be able to test for an empty sequence.
18. It provides the usual iterator operations: ```++``` (advance forward), ```--``` (advance backward), ```*``` (dereference), ```==``` (is equal to), and ```!=``` (is not equal to).
19. You can iterate over a container using the STL by providing ```begin()``` and ```end()``` for a container. All the algorithms in the STL require iterator arguments, very often two: one to the beginning of a sequence and one to one-past-the-last-element.
20. One might use a string rather than a vector if the "specific text manipulation operations" that string provides are more suitable for the solution being provided -- and, assumedly, it is the case that the data worked with are exclusively character elements. For example, string provides concatenation whereas vector does not. 
21. One might use a list rather than a vector if the solution requires fast/efficient insertion/deletion operations and the lack of subscripting does not affect the ease of use. Insertion/deletion in a vector requires moving elements -- possibly, inefficient for large collections of data -- whereas lists do not require moving elements. 
22. A container is a collection of data elements, or put another way it is a storage solution for data. Besides the data values that it contains, a container provides facilities for adding and removing elements, reporting the number of elements, and manages the memory (if not oursourced to a separate allocator).
23. ```begin()``` should provide a pointer to the first element of a sequence; ```end()``` should provide a pointer to one-past-the-last element. 